%title: 链接的过程
%class: 链接
\section{一个误区}
我一直认为在链接静态库的时候. 链接器会在静态库中抽取相关的代码而不是把整个静态库链接进来. 
这种看上去好像没有问题的看法其实是不对的. 

这里我们要说一下静态库的结构了. 其实在打包静态库的时候我们可能已经意识到了: 太简单了. 
是不是这样的? 我们在打包静态库的时候会发现相对于复杂的编译与动态库的编译之类的, 打包静态库是不是
太简单了. 

是这样的. 对于静态库的生成是很简单的过程. 这个过程只是很简单地把多个目标文件包含在了一起. 
也就是说静态库的结构就是多个目标文件集合.

而链接的单位是目标文件. 也就是说链接静态库的时候, 会取静态库中的多个目标文件中相关的目标文件进行链接.

而我原来的误区是链接会抽取库中的相关代码. 其实链接是以目标文件为单位的.

\section{一个不解}
在正常的链接中可能没有什么问题. 但是当链接多个目标文件与库, 并且这些目标文件与库之间有依赖关系的时候. 链接就会
变得不那么简单了. 

链接的过程中会维护一些信息:所有的目标文件的集合E. 所有引用但是没有解决的符号集合U. 所有的
集合E 中的所有目标文件定义的符号.

\startitemize
\item  [原则1] 从左向右扫描所有的命令行上出现的目标文件或库.
\stopitemize


如果没有库只有目标文件其实是没有任何问题的. 因为最终所有的目标文件都会被包含进来这样必然是可以完成所有的符号集合U
中的引用. 
正是由于目标文件存在.才会形成这个不解. 但是如果使用一个比较简单的方法, 把库中的所有的目标文件都引用了也许事情
并不会变得麻烦. 
不幸的是我们还有一个要求: 只使用库文件中相关的动态库.
那么为了达到这样的要求. 链接器在扫描库文件的中的所有的目标文件的时候, 只把定义有U中的符号的目标文件放到E中. 
这样带来的问题是如果在这之后想要引用库中的其它的目标文件都会失败. 因为这些目标文件没有加入到集合E中.

其实说了这么多什么时候会出现问题呢? 大多时候我们把库文件放到最后就是了. 如果库中引用了另一个库才出现问题. 
但是只要调整库的位置也没有什么不是吗? 一个极端的情况是两个库想到依赖. 哈哈! 你遇到事了. 解决方法是可以把一个
库文件在命令行上写两次如:
\starttyping
gcc foo.c libx.a liby.a libx.a
\stoptyping

\section{一个细节}
注意到一件事, 对于库文件的扫描与对于命令行上的所有的目标文件的扫描没有什么分别. 那如果在这个库中也出现了相互之间的引用呢?
这里很有意思是一个细节. 对于库文件的扫描是在U, D 都没有再变化的时候才结束的. 也就是说是对于其进行反复扫描而完成对一个库文件的扫描.







